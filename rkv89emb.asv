function [epoch, output_state] = rkv89emb(f, t,y, stepSize, tfinal)
%UNTITLED Summary of this function goes here
%   Detailed explanation goes here

% Settings
max_attempts = 50;
tolerance = 1e-11; % 1e-13;
minimumStep = 1e-13;
maximumStep = 2700;
%goodStepTaken = false; % 1 if good step was taken
%currentAttempts = 0;
sigma = 0.9;
initial_step = 60;
stepSize = initial_step;


global checkrkv89_emb;

if ~checkrkv89_emb
  if (t + stepSize) > tfinal
      finalStep = true;
      final = true;
      stepSize = tfinal - t; % added recently
  end
else 
    if (t + stepSize) < tfinal
      finalStep = true;
      final = true;
      stepSize = tfinal - t;
    end
end

while t < tfinal
        if (t + stepSize) > tfinal
            stepSize = tfinal - t;
        end
        
        goodStepTaken = false;
        currentAttempts = 0;
        
        while not(goodStepTaken)
            
            % Check stepSize
            if (abs(stepSize) < minimumStep) %&& not(finalStep))
               if stepSize > 0.0 
                stepSize = minimumStep;
                else
                stepSize = -minimumStep;
               end
            end
  
             if (abs(stepSize) > maximumStep)
                if stepSize > 0.0 
                stepSize = maximumStep;
             else
                stepSize = -maximumStep;
                end
             end
             
             % Calculate raw state and the error (column vector)
             [errh, state] = RungeKutta89_2(f,y,t,stepSize);
             % Find max error component
             error = maxerror(errh, state, y); 
             %stepTaken = stepSize;
            
             % Check the error
             if (error ~= 0.0)
           
                 if (error > tolerance)               
                     stepSize = sigma * stepSize * ((tolerance/error)^(1/8));
                        if (abs(stepSize) < minimumStep)
                           if stepSize < 0.0 
                                stepSize = -minimumStep;
                           else
                                stepSize = minimumStep;
                           end
                        end

                        if (abs(stepSize) > maximumStep)
                           if stepSize > 0.0 
                                stepSize = maximumStep;
                           else
                                stepSize = -maximumStep;
                           end
                        end
                    currentAttempts = currentAttempts+1;
                else 
                       stepSize = sigma * stepSize * ((tolerance/error)^(1/9)); 
                       currentAttempts = 0;
               
                       if (abs(stepSize) > maximumStep)
                           if stepSize > 0.0 
                                stepSize = maximumStep;
                           else
                                stepSize = -maximumStep;
                           end
                       end

                       if (abs(stepSize) < minimumStep) %&& not(finalStep))
                            if stepSize > 0.0 
                                stepSize = minimumStep;
                            else
                                stepSize = -minimumStep;
                            end
                       end

                        % Add new column to output vectors
                       output_state = [output_state; state];
                       goodStepTaken = true;
                end
           %%%%
           
             else  
                 output_state = [output_state; state];
                 currentAttempts = 0;
                 goodStepTaken = true;
            end
            
        end
    
end

  % Start checking
  while not(goodStepTaken)
      
      if (abs(stepSize) < minimumStep) %&& not(finalStep))
        if stepSize > 0.0 
            stepSize = minimumStep;
        else
            stepSize = -minimumStep;
        end
      end
  
  if (abs(stepSize) > maximumStep)
       if stepSize > 0.0 
            stepSize = maximumStep;
       else
            stepSize = -maximumStep;
       end
  end
      
       [errh, state] = RungeKutta89_2(f,y,t,stepSize);

       error = maxerror(errh, state, y); % 3rd can be temporary_raw or y, don't know for sure yet
        % error = (max(abs(errh)));

        stepTaken = stepSize;
        
        if (error ~= 0.0)
           %%%%
           if (error > tolerance)
               
                stepSize = sigma * stepSize * ((tolerance/error)^(1/8));

                if (abs(stepSize) < minimumStep)
                    if stepSize < 0.0 
                        stepSize = -minimumStep;
                    else
                        stepSize = minimumStep;
                    end
                    
                 if (abs(stepSize) > maximumStep)
                   if stepSize > 0.0 
                        stepSize = maximumStep;
                   else
                        stepSize = -maximumStep;
                   end
                 end

                    currentAttempts = currentAttempts+1;
                    disp(currentAttempts);
                end 
           else % if error is okay, within the tolerance boundaries
               stepSize = sigma * stepSize * ((tolerance/error)^(1/9)); 
               %output_state = state;
               currentAttempts = 0;
               
               if (abs(stepSize) > maximumStep)
                   if stepSize > 0.0 
                        stepSize = maximumStep;
                   else
                        stepSize = -maximumStep;
                   end
               end
               
                if (abs(stepSize) < minimumStep) %&& not(finalStep))
                    if stepSize > 0.0 
                        stepSize = minimumStep;
                    else
                        stepSize = -minimumStep;
                    end
               end

                  output_state = state;
                  step_for_next = stepSize;
                  goodStepTaken = true;

           end
           %%%%
           
        else  % 0.0 means no need for error control; in that case leave step alone
           %memcpy(outState, candidateState, dimension*sizeof(Real));
           output_state = state; 
           currentAttempts = 0;
           %step_for_next = stepTaken;
           step_for_next = stepTaken;
           goodStepTaken = true;
        end
        
        if (currentAttempts >= max_attempts)
           %return false;
           disp('Bad step');
           %stepTaken = stepSize;
           step_for_next = stepTaken;
           output_state = state;
           goodStepTaken = true; % actually no, but I have to leave the while loop
           
        end
      
  end

end